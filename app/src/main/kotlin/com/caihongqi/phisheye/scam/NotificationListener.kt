package com.caihongqi.phisheye.phisheye

import android.app.Notification
import android.content.ComponentName
import android.content.pm.PackageManager
import android.service.notification.NotificationListenerService
import android.service.notification.StatusBarNotification
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import android.provider.ContactsContract
import java.util.concurrent.ConcurrentHashMap
import org.fossify.commons.extensions.getMyContactsCursor

class NotificationListener : NotificationListenerService() {

    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    private val spamHandler by lazy { SpamHandler(this) }

    override fun onListenerConnected() {
        super.onListenerConnected()
        Log.d(TAG, "Listener connected successfully.")
        isServiceConnected = true
        NotificationDataHolder.updateServiceState(true)
        // NO startForeground() calls
    }

    override fun onListenerDisconnected() {
        super.onListenerDisconnected()
        Log.w(TAG, "Listener disconnected.")
        isServiceConnected = false
        NotificationDataHolder.updateServiceState(false)
    }

    override fun onDestroy() {
        serviceScope.cancel()
        isServiceConnected = false
        NotificationDataHolder.updateServiceState(false)
        super.onDestroy()
    }

    override fun onNotificationPosted(sbn: StatusBarNotification?) {
        super.onNotificationPosted(sbn)
        if (sbn == null) return

        val sourcePackage = sbn.packageName
        if (sourcePackage == packageName) {
            Log.v(TAG, "Ignoring notification generated by PhishEye.")
            return
        }

        val prefs = getSharedPreferences("phisheye_settings", android.content.Context.MODE_PRIVATE)
        val filterOtherApps = prefs.getBoolean("filter_other_apps", false)

        if (!filterOtherApps) {
            return
        }

        val filterWhatsapp = prefs.getBoolean("filter_whatsapp", false)
        val filterTelegram = prefs.getBoolean("filter_telegram", false)

        val isWhatsApp = sourcePackage == "com.whatsapp" || sourcePackage == "com.whatsapp.w4b"
        val isTelegram = sourcePackage == "org.telegram.messenger" || sourcePackage == "org.telegram.messenger.web"

        var isAllowed = false
        if (isWhatsApp && filterWhatsapp) isAllowed = true
        if (isTelegram && filterTelegram) isAllowed = true

        if (!isAllowed) {
            return
        }

        val notification = sbn.notification
        val extras = notification.extras

        val title = extras.getString(Notification.EXTRA_TITLE)
        val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString()

        Log.d(
            TAG,
            "Notification received: App='${sourcePackage}' Title='${title}' Text='${text}'"
        )

        val trimmedText = text?.trim()
        if (trimmedText.isNullOrEmpty()) {
            return
        }

        val safeTitle = title?.trim() ?: ""
        val appLabel = resolveAppLabel(sourcePackage)

        val info = NotificationInfo(sourcePackage, appLabel, safeTitle, trimmedText)
        serviceScope.launch {
            try {
                if (isContact(safeTitle)) {
                    Log.d(TAG, "Skipping AI for trusted contact: $safeTitle")
                    return@launch
                }
                val analyzed = spamHandler.analyzeContent(info)
                NotificationDataHolder.onNewNotification(analyzed)
                if (analyzed.prediction.equals("SPAM", ignoreCase = true)) {
                    spamHandler.showSpamAlertNotification(analyzed)
                }
            } catch (ex: Exception) {
                Log.e(TAG, "Failed to analyze notification: ${ex.message}", ex)
            }
        }
    }

    private fun isContact(name: String): Boolean {
        if (name.isBlank()) return false
        val cursor = getMyContactsCursor(favoritesOnly = false, withPhoneNumbersOnly = false)
        try {
            if (cursor?.moveToFirst() == true) {
                val nameIndex = cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME_PRIMARY)
                if (nameIndex != -1) {
                    do {
                        val contactName = cursor.getString(nameIndex)
                        if (name.equals(contactName, ignoreCase = true)) {
                            return true
                        }
                    } while (cursor.moveToNext())
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking contacts", e)
        } finally {
            cursor?.close()
        }
        return false
    }

    private fun resolveAppLabel(packageName: String): String {
        val cached = appLabelCache[packageName]
        if (!cached.isNullOrBlank()) {
            return cached
        }

        val resolved = try {
            val appInfo = packageManager.getApplicationInfo(packageName, 0)
            packageManager.getApplicationLabel(appInfo).toString()
        } catch (ex: PackageManager.NameNotFoundException) {
            Log.w(TAG, "Unable to resolve app label for $packageName", ex)
            packageName
        }

        appLabelCache[packageName] = resolved
        return resolved
    }

    companion object {
        private const val TAG = "NotificationListener"
        private val appLabelCache = ConcurrentHashMap<String, String>()
        @Volatile
        private var isServiceConnected: Boolean = false

        fun isServiceConnected(): Boolean = isServiceConnected

        fun requestRebind(context: android.content.Context) {
            val componentName = ComponentName(context, NotificationListener::class.java)
            try {
                requestRebind(componentName)
                Log.d(TAG, "Requested notification listener rebind.")
            } catch (ex: IllegalArgumentException) {
                Log.e(TAG, "Failed to request rebind: ${ex.message}", ex)
            }
        }
    }
}
