package org.fossify.messages.phisheye

import android.Manifest
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.ComponentName
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.service.notification.NotificationListenerService
import android.service.notification.StatusBarNotification
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.fossify.messages.BuildConfig
import org.fossify.messages.R
import org.fossify.messages.activities.MainActivity
import java.util.concurrent.ConcurrentHashMap

class NotificationListener : NotificationListenerService() {

    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    private val spamDetector by lazy { SpamDetector(this) }
    private val groqVerifier by lazy { GroqSpamVerifier(BuildConfig.GROQ_API_KEY) }
    private val detectionHistoryRepository by lazy {
        DetectionHistoryRepository.getInstance(this)
    }

    private val hasGroqApiKey: Boolean
        get() = BuildConfig.GROQ_API_KEY.isNotBlank()

    override fun onListenerConnected() {
        super.onListenerConnected()
        Log.d(TAG, "Listener connected successfully.")
        isServiceConnected = true
        NotificationDataHolder.updateServiceState(true)
        // NO startForeground() calls
    }

    override fun onListenerDisconnected() {
        super.onListenerDisconnected()
        Log.w(TAG, "Listener disconnected.")
        isServiceConnected = false
        NotificationDataHolder.updateServiceState(false)
    }

    override fun onDestroy() {
        serviceScope.cancel()
        isServiceConnected = false
        NotificationDataHolder.updateServiceState(false)
        super.onDestroy()
    }

    override fun onNotificationPosted(sbn: StatusBarNotification?) {
        super.onNotificationPosted(sbn)
        if (sbn == null) return

        val sourcePackage = sbn.packageName
        if (sourcePackage == packageName) {
            Log.v(TAG, "Ignoring notification generated by PhishEye.")
            return
        }

        val notification = sbn.notification
        val extras = notification.extras

        val title = extras.getString(Notification.EXTRA_TITLE)
        val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString()

        Log.d(
            TAG,
            "Notification received: App='${sourcePackage}' Title='${title}' Text='${text}'"
        )

        val trimmedText = text?.trim()
        if (trimmedText.isNullOrEmpty()) {
            return
        }

        val safeTitle = title?.trim() ?: ""
        val appLabel = resolveAppLabel(sourcePackage)

        val info = NotificationInfo(sourcePackage, appLabel, safeTitle, trimmedText)
        serviceScope.launch {
            try {
                val analyzed = analyzeNotification(info)
                NotificationDataHolder.onNewNotification(analyzed)
                if (analyzed.prediction.equals("SPAM", ignoreCase = true)) {
                    showSpamAlertNotification(analyzed)
                }
            } catch (ex: Exception) {
                Log.e(TAG, "Failed to analyze notification: ${ex.message}", ex)
            }
        }
    }

    private suspend fun analyzeNotification(info: NotificationInfo): AnalyzedNotification {
        val (localLabel, localConfidence) = try {
            withContext(Dispatchers.Default) {
                spamDetector.predict(info.text)
            }
        } catch (ex: Exception) {
            Log.e(TAG, "Local spam detection failed: ${ex.message}", ex)
            // Fallback to simple heuristic if model fails
            Pair("HAM", 0.5f)
        }

        var finalLabel = localLabel
        var finalConfidence = localConfidence
        var analysisSource = "local"
        var reason: String? = null

        val shouldQueryRemote = hasGroqApiKey &&
                (localLabel.equals("ERROR", ignoreCase = true) || localConfidence < SECONDARY_CONFIDENCE_THRESHOLD)

        if (shouldQueryRemote) {
            val remoteResult = withContext(Dispatchers.IO) {
                groqVerifier.verify(info)
            }
            if (remoteResult != null) {
                finalLabel = remoteResult.label
                finalConfidence = remoteResult.confidence
                analysisSource = "remote"
                reason = remoteResult.reason
            }
        }

        val analyzed = AnalyzedNotification(
            info = info,
            prediction = finalLabel,
            confidence = finalConfidence,
            analysisSource = analysisSource,
            reason = reason
        )

        try {
            detectionHistoryRepository.logDetection(analyzed)
        } catch (ex: Exception) {
            Log.w(TAG, "Failed to persist detection history: ${ex.message}", ex)
        }

        return analyzed
    }


    private fun showSpamAlertNotification(result: AnalyzedNotification) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            val permissionGranted = ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
            if (!permissionGranted) {
                Log.w(TAG, "POST_NOTIFICATIONS permission missing; skipping spam alert.")
                return
            }
        }

        val notificationManager = NotificationManagerCompat.from(this)
        if (!notificationManager.areNotificationsEnabled()) {
            Log.w(TAG, "Notifications are disabled for PhishEye; spam alert suppressed.")
            return
        }

        ensureSpamAlertChannel()

        val notificationId = spamNotificationCounter.incrementAndGet()
        val appName = result.info.appName.ifBlank { result.info.packageName }
        val previewText = result.info.title.takeIf { it.isNotBlank() } ?: result.info.text
        val alertTitle = "⚠️ Likely Spam Detected from $appName"

        val launchIntent = Intent(this, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        val pendingIntent = PendingIntent.getActivity(
            this,
            notificationId,
            launchIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val notification = NotificationCompat.Builder(this, SPAM_ALERT_CHANNEL_ID)
            .setSmallIcon(android.R.drawable.stat_sys_warning)
            .setContentTitle(alertTitle)
            .setContentText(previewText)
            .setStyle(NotificationCompat.BigTextStyle().bigText(result.info.text))
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_SYSTEM)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .build()

        try {
            notificationManager.notify(notificationId, notification)
        } catch (ex: SecurityException) {
            Log.e(TAG, "Unable to post spam alert notification: ${ex.message}", ex)
        }
    }

    private fun ensureSpamAlertChannel() {
        val manager = getSystemService(NotificationManager::class.java) ?: return
        val channel = manager.getNotificationChannel(SPAM_ALERT_CHANNEL_ID)
        if (channel == null) {
            val spamChannel = NotificationChannel(
                SPAM_ALERT_CHANNEL_ID,
                SPAM_ALERT_CHANNEL_NAME,
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = SPAM_ALERT_CHANNEL_DESCRIPTION
                enableVibration(true)
            }
            manager.createNotificationChannel(spamChannel)
        }
    }

    private fun resolveAppLabel(packageName: String): String {
        val cached = appLabelCache[packageName]
        if (!cached.isNullOrBlank()) {
            return cached
        }

        val resolved = try {
            val appInfo = packageManager.getApplicationInfo(packageName, 0)
            packageManager.getApplicationLabel(appInfo).toString()
        } catch (ex: PackageManager.NameNotFoundException) {
            Log.w(TAG, "Unable to resolve app label for $packageName", ex)
            packageName
        }

        appLabelCache[packageName] = resolved
        return resolved
    }

    companion object {
        private const val TAG = "NotificationListener"
        private val appLabelCache = ConcurrentHashMap<String, String>()
        private const val SPAM_ALERT_CHANNEL_ID = "phisheye_spam_alerts"
        private const val SPAM_ALERT_CHANNEL_NAME = "Spam Alerts"
        private const val SPAM_ALERT_CHANNEL_DESCRIPTION =
            "Warnings generated when PhishEye detects likely spam."
        private const val SECONDARY_CONFIDENCE_THRESHOLD = 0.75f
        private val spamNotificationCounter = java.util.concurrent.atomic.AtomicInteger(2000)
        @Volatile
        private var isServiceConnected: Boolean = false

        fun isServiceConnected(): Boolean = isServiceConnected

        fun requestRebind(context: android.content.Context) {
            val componentName = ComponentName(context, NotificationListener::class.java)
            try {
                requestRebind(componentName)
                Log.d(TAG, "Requested notification listener rebind.")
            } catch (ex: IllegalArgumentException) {
                Log.e(TAG, "Failed to request rebind: ${ex.message}", ex)
            }
        }
    }
}
